---
title: "Python的字符编码问题"
date: 2016-04-22
---

# 坑爹的字符编码问题

昨晚看了一篇讲解Python中字节与字符串的文章,由此为开头,又开启了对Python中字符编码问题的探究。

以前粗略了解ascii gbk utf-8 Unicode,大概掌握了decode和encode的概念,但越来越发现,仅仅这些概念还不够,还有一些东西需要了解清楚,否则只是盲目的decode来encode去的,很容易自己被自己搞晕。

首先要明确一点，2.x和3.x中对字符串的表示有了根本的区别。

2.x中,str为某一种编码方式encode之后的字节码构成的字节流。

3.x中,str为Unicode对象,内部就是用的Unicode字符集里的字符,是真正意义上的字符串。

所以导致了一个很奇葩的事情的:

>2.x中str要选择合适的编码decode为Unicode字符集后才能转化为其它编码下的字节流,在2.x中就是str。

3.x中呢,多了一个类型,字节byte

而str默认为Unicode对象，当然地，只有encode方法,不再有decode方法,啊,老天爷,绕死我了.

简而言之,在我们人类看起来没什么不同的字符串,在2和3中的Python眼中,已经成了完全不同的东西.而作为程序广义输入的的入口,这相当于我们输入给Python程序的东西,变了,这很蛋疼啊!

不过,3.x中的方法才是未来，尽量向这个方向靠是没错的。

所以,目前有一个比较好的处理方式。虽然2.x中没有字节的概念,但已经有了方法可以将str默认转化为Unicode对象.

> from \__future__ import unicode_literals

要注意的是,最好将2.x中默认的str编码方式设定为utf-8，否则没法很好地支持国际化。其实汉语就是很国际化的代码了，就字符编码而言，挺复杂的。采用utf-8编码的好处是，你输入的字符串几乎都能得到支持，因为其背后用的字符集就是Unicode的字符集嘛。

> #-\*- coding:utf-8 -*-

容我再回味一下,在2.x中,unicode对象可以encode,但str默认是字节码，所以最好decode为unicode后再encode转码。如果将str直接encode也能运行,因为Python会自动先将str解码为unicode之后再编码,而坑爹的是：**这里的解码用的是默认的ascii。**

在3.x中，才算正常，str就是Unicode字符集，然后输出到控制台时，由控制台自行编码，输出到文件时，也可以由文件编辑器自行编码。

>此外还有一点要注意，在2.x中，如果调用方法将str转化为Unicode对象，在输出控制时不会有问题，但在__write（‘filename’）__时仍会出问题，因为write方法不会自行编码，我们必须指定编码方式将Unicode编码为str类型。

所以,暂时就是又了解了这么些,字符集,字节流,Unicode,以及2和3的重大区别,以及怎么在2中采用默认unicode的字符串.


以后尽量这么对待字符串:就是将str都统一为Unicode,让各个控制台去自己做决定,转化为人类可识别的字符.

还有一个方法:__repr(str)__, 可以查看程序中str真正意义上是用什么格式存储的。在不确定的情况下，可以尝试用它来进行判断。
