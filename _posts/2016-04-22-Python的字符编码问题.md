---
title: "Python的字符编码问题"
date: 2016-04-22
---

# 坑爹的字符编码问题

昨晚看了一篇讲解Python中字节与字符串的文章,由此为开头,又开启了对Python中字符编码问题的探究.

以前粗略了解ascii gbk utf-8 Unicode,大概掌握了decode和encode的概念,但越来越发现,仅仅这些概念还不够,还有一些东西需要了解清楚,否则只是盲目的decode来encode去的,很容易自己被自己搞晕.

首先,明确2.x和3.x中对字符串的表示有了根本的区别.

2.x中,str为某一种编码方式encode之后的字节码构成的字节流.

3.x中,str为Unicode对象,内部就是用的字符集里的字符,是真正意义上的字符串.

所以导致了一个很奇葩的事情的:2.x中str要decode为Unicode字符集才能转化为其它编码下的字节流,在2.x中就是str.

3.x中呢,多了一个类型,字节,byte

而身为Unicode的str只有encode方法,不再有decode方法,啊,老天爷,绕死我了.

简而言之,在我们人类看起来没什么不同的字符串,在2和3中的Python眼中,已经成了完全不同的东西.而作为程序广义输入的的入口,这相当于我们输入给Python程序的东西,变了,这很蛋疼啊!

不过,3.x中的方法才是未来啊!

所以,虽然2.x中没有字节的概念,但已经有了方法将str默认为Unicode对象.

> from __future__ import unicode_literals

此外,要将2.x中默认的str编码方式设定为utf-8

> #-*- coding:utf-8 -*-

我再回味一下,在2.x中,unicode对象可以encode,str最好decode为unicode后在encode转码.如果str直接encode也可以,就是为造成编码错误,因为Python会自动先将str解码为unicode之后再编码,而这里的解码用的是默认的ascii.

所以,暂时就是又了解了这么些,字符集,字节流,Unicode,以及2和3的重大区别,以及怎么在2中采用默认unicode的字符串.


以后尽量这么对待字符串:就是将str都统一为Unicode,让各个控制台去自己做决定,转化为人类可识别的字符.

还有一个方法:repr(str), 可以查看程序中str真正意义上是用什么格式存储的.
