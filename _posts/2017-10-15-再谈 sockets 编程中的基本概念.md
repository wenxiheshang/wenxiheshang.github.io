---
'title': '再谈 sockets 编程中的基本概念'
'date': 2017-10-15
---
# 再谈 sockets 编程中的基本概念

上一次，主要谈了三个点：
- sockets 作为跨平台的 IPC 形式中的唯一玩家，负责在应用层的底层驱动着整个互联网的通信 
- 通信模式一般为「服务端-客户端」，端到端
- 通常为 block 模式，需要利用 thread 或 select 实现非阻塞

这一次，再谈一些更具体的概念：

- 动作与持续行为
	- 在通讯被搭建起来的整个过程中，socket 有时执行一个动作，有时执行一个行为，行为往往是持续的。动作改变 socket 所处的状态，行为可以返回结果，结果可以多种多样
- 网络字节和本级字节的相互转换
	- 不同硬件，甚至不同协议下的数据很可能具备不一样的字节
	- 在网络通讯中，字节转换必然是一个频繁现象
- socket 与 TCP／IP 协议
	- 协议本身与 socket 这个具体实现无关
	- socket 的实现却需要在某种协议下进行
	- TCP／IP 协议下的 sockets 通讯，本质上两个携带 IP／PORT 地址的 socket 线程之间的通讯
- 基于 stream 的 TCP 简易通讯模型
	- TCP 连接通过三次握手实现，需要各自建立连接，也需要各自断开
	- 连接一旦建立，便是持续性的
	- 连接实现为在物理上开放，在抽象上封闭的双向管道模式
	- 数据包的发送和接收实际上是非连续的，网络层 IP 协议不保证数据包一定抵达，也不保证数据包按先后次序抵达，这种在实际通讯中必须得到的保证是由传输协议 TCP 实现的
- 服务器
	- 创建 socket ，绑定特定地址到 socket ，命令 已经携带地址的 socket 进入监听状态，命令监听状态下的 socket 执行 accept 行为，行为的目标是新建一个同时携带服务端地址与客户端地址的已连接 socket，并用这个已连接 socket 与客户端 socket 进行通信
	- 一个服务器只有一个监听 socket ，负责 accept 客户端 socket，并建立一个已连接 socket 与客户端 socket 进行通信
- 客户端
	- 创建 socket，发起 connect ，将本地 socket 绑定到网络中的另一个 socket 之上，之后可以开始发送并接收数据，最后可以关闭连接
	- 通过操作系统内核创建的 socket 默认为可以主动发起连接请求的客户端 socket，这也是服务器端创建 socket 之后，需要通过 listen 函数显式进入被动监听状态的原因
	- 至于 bind 函数，只是将 socket 关联到一个 socket 类型的地址上
	- 所以，某种程度上将，bind 和 connect 更为类似，只不过 bind 是绑定到本地，connect 是绑定到网络中另一个计算机上
- 通信的前哨
	- 客户端的 connect 与 服务器端的 accept 结对生成 socket link
	- 通信就是在这条 link 上进行
	- 为了通信，客户端和服务器端都需要做一些准备工作
	- 服务器端几乎是昼夜不眠，时刻准备着，所以有一个 listen
	- 客户端按需现造 socket 之后，主动 connect 之后与时刻准备着的服务器端建立一个临时的连接，进行通讯，结束之后，双方可以各自关闭连接
- IP 与 域名
	- 一个 IP 下某个端口下的进程可以与另一个 IP 下某个端口下的进程进行通讯
	- 在浏览器中，我们输入一个域名后，域名将会被解析为某个 IP 地址
	- 域名解析完全是为了服务人